---
  title: "Test LMOK"
  author: "X. Freulon, N. Desassis, H. Wackernagel"
  date: "31 juillet 2022"
  output:
    pdf_document: default
    html_document: default
---

# Initialisation

```{r R_init, echo=TRUE, eval=TRUE}
knitr::opts_chunk$set(echo = TRUE)
library(RGeostats)
library(Matrix)
rm(list=ls())
constant.define("asp",1)
set.seed(seed=125875)
nsim = 1000
```
# Fonctions

```{r LMOK_init, echo = TRUE, eval=TRUE}
source(file = "./functions_kriging.R")
source(file = "./functions_spde.R")
source(file = "./functions_Xval.R")
```

# Test data

```{r data_init, echo = TRUE, eval=TRUE}
load(file = "../Data/test_LMOK.RData")
# Surface for Type "a"
grd <- db.locate(grd, names = "a.S", loctype = "z", flag.locnew = TRUE)
dat <- db.locate(dat, names = "a.S", loctype = "z", flag.locnew = TRUE)
plot(grd, pos.legend = 8)
plot(dat, add = TRUE)

# selections on the input database
sel_train <- rep(FALSE, dat$nech)
sel_train[sort(sample(1:dat$nech, 100))] <- TRUE
dat <- db.add(dat, sel_train)
dat <- db.add(dat, sel_train_a = as.numeric(sel_train & (dat$Type == 1)))
dat <- db.add(dat, sel_train_b = as.numeric(sel_train & (dat$Type == 2)))
dat <- db.add(dat, Un = 1.0)
```

# model

```{r Model_init, echo = TRUE, eval = TRUE}
# Paramètres du modèle
sigma   <- c(2, 3)  # Ecart type de l'erreur de modélisation
coef_1  <- c(2.5, 3.5, 0.7)   #  coefficient de la première corégionalisation
coef_2  <- c(5.0, 7.0, 0.8)   #  coefficient de la seconde corégionalisation
ab      <- matrix(c(12, 9, 5, 12), 2, 2) # Espérance des coefficients pour 
range   <- c(0.15, 0.25)  # Portée pratique des deux covariance de Matern

N_mean  <- c(3, 6) # Moyenne du nombre de pièces 

np      <- 100      # Nombre de points de données
p       <- 0.2      # Proportion de données testées pour la validation
nu      <- 3        # Coefficient de la covariance de Matern
nodes   <- c(100,100) # Valeur par default pour le meshing
margin  <- 0.2      # Proportion pour l'extension de la zone à mailler

# Paramètres pour le cokrigeag des biens (a) et (b)
param_CoefBi <- list(nodes   = nodes, margin  = margin,
  type = "bivar", 
  nu = nu, 
  coef_1 = coef_1, 
  coef_2 = coef_2, 
  sigma = sigma, 
  range = range
  )

# Parametres pour le krigeage des biens (a)
param_IndFac_a <- list(nodes   = nodes, margin  = margin,
  type = "IndFac", 
  nu = nu,
  sigma_1 = coef_1[1],
  sigma_2 = coef_2[1],
  sigma   = sigma[1],
  range_1 = range[1],
  range_2 = range[2]
)

# Parametres pour le krigeage des biens (b)
param_IndFac_b <- list(nodes   = nodes, margin  = margin,
  type = "IndFac", 
  nu = nu,
  sigma_1 = coef_1[2],
  sigma_2 = coef_2[2],
  sigma   = sigma[2],
  range_1 = range[1],
  range_2 = range[2]
)

param_IntFac_a <- list(nodes   = nodes, margin  = margin,
  type = "IntFac", 
  nu = nu,
  sigma_1 = coef_1[1],
  sigma_2 = coef_2[1],
  tau     = 0.7,
  sigma   = sigma[1],
  range   = range[1]
)

param_IntFac_b <- list(nodes   = nodes, margin  = margin,
  type = "IntFac", 
  nu = nu,
  sigma_1 = coef_1[2],
  sigma_2 = coef_2[2],
  tau     = 0.5,
  sigma   = sigma[2],
  range   = range[1]
)

# Parametres pour le cokrigeage des biens (a) et (b) equivalent à un krigeage indépendant
param_CoefBi_ind <- param_CoefBi
param_CoefBi_ind$coef_1[3] <- 0.0
param_CoefBi_ind$coef_2[3] <- 0.0
```

fonction de comparaison (eg. LMOK vs. SPDE_LMOK)

```{r eval_LMOK_fn, echoTRUE, eval=TRUE}

correlation_LMOK <- function(model, grd, pref, name1, name2, idx = 1:3){
  sufix1 <- c("estim", "estim", "stdev")[idx]
  sufix2 <- c("estim", "ce.estim", "ce.stdev")[idx]
  for (i in 1:model$nvar) {
    for (k in seq_along(sufix1)){
      correlation(grd, flag.iso = TRUE, flag.diag = TRUE, diag.col = "red",
      name1 = paste(name1, pref, paste0("Z", i), sufix1[k], sep = "."),
      name2 = paste(name2, pref, paste0("Z", i), sufix2[k], sep = ".")
      )
    }
  }
  return(NULL)
}
```


# Mise en oeuvre du LMOK en mono-variable

# Cas mono-facteur

## Constante $1$

$$
S_k = Z_1(s_k) \times 1 + \epsilon_k
$$

### Type (a)

```{r eval_LMOK_Un_a, echo=TRUE, eval=TRUE}
# re-initialisation
dat  <- db.locerase(dat, "z")
dat  <- db.locerase(dat, "f")
dat  <- db.locerase(dat, "code")
dat  <- db.locerase(dat, "sel")
dat  <- db.delete(dat, "sigma2")
# Definition du modèle
param <- param_IndFac_a; pref <- "Un.a"
m     <- SPDE_param2model(param = param)
m     <- model.reduce(m, vars = 1, structs = 1)
dat   <- db.add(dat, sigma2 = param$sigma^2)

# Selection des variables
dat <- db.locate(dat, name = c("N"), loctype = "f", flag.locnew = TRUE)
dat <- db.locate(dat, name = c("S"), loctype = "z", flag.locnew = TRUE)
dat <- db.locate(dat, name = c("sigma2"), loctype = "v", flag.locnew = TRUE)
dat <- db.locate(dat, name = c("sel_train_a"), loctype = "sel", flag.locnew = TRUE)

grd <- LMOK_kriging(grd, dbin = dat, model = m, 
                    idx = NA, flag.estim = TRUE, flag.stdev = TRUE,
                    radix = paste("LMOK", pref, sep = "."), verbose = TRUE)
grd <- SPDE_LMOK_krigsim(grd, dbin = dat, model = m, 
                    nsim = 0, flag.ce = FALSE,
                    radix = paste("SPDE_LMOK", pref, sep = "."), verbose = TRUE)
grd <- SPDE_LMOK_krigsim(grd, dbin = dat, model = m, 
                    nsim = 1000, flag.ce = TRUE,
                    radix = paste("SPDE_LMOK", pref, sep = "."), verbose = TRUE)

correlation_LMOK(m, grd, pref, name1 = "LMOK", name2 = "SPDE_LMOK")
```

### Type (b)

```{r eval_LMOK_Un_b, echo=TRUE, eval=TRUE}
# re-initialisation
dat  <- db.locerase(dat, "z")
dat  <- db.locerase(dat, "f")
dat  <- db.locerase(dat, "code")
dat  <- db.locerase(dat, "sel")
dat  <- db.delete(dat, "sigma2")
# Definition du modèle
param <- param_IndFac_b; pref <- "Un.b"
m     <- SPDE_param2model(param = param)
m     <- model.reduce(m, vars = 1, structs = 1)
dat   <- db.add(dat, sigma2 = param$sigma^2)

# Selection des variables
dat <- db.locate(dat, name = c("N"), loctype = "f", flag.locnew = TRUE)
dat <- db.locate(dat, name = c("S"), loctype = "z", flag.locnew = TRUE)
dat <- db.locate(dat, name = c("sigma2"), loctype = "v", flag.locnew = TRUE)
dat <- db.locate(dat, name = c("sel_train_b"), loctype = "sel", flag.locnew = TRUE)

grd <- LMOK_kriging(grd, dbin = dat, model = m, 
                    idx = NA, flag.estim = TRUE, flag.stdev = TRUE,
                    radix = paste("LMOK", pref, sep = "."), verbose = TRUE)
grd <- SPDE_LMOK_krigsim(grd, dbin = dat, model = m, 
                    nsim = 0, flag.ce = FALSE,
                    radix = paste("SPDE_LMOK", pref, sep = "."), verbose = TRUE)
grd <- SPDE_LMOK_krigsim(grd, dbin = dat, model = m, 
                    nsim = 1000, flag.ce = TRUE,
                    radix = paste("SPDE_LMOK", pref, sep = "."), verbose = TRUE)

correlation_LMOK(m, grd, pref, name1 = "LMOK", name2 = "SPDE_LMOK")
```

## Nombre de pièces $N$

$$
S_k = Z_1(s_k) \times N_k + \epsilon_k
$$

### Type (a)

```{r eval_LMOK_N_a, echo=TRUE, eval=TRUE}
# re-initialisation
dat  <- db.locerase(dat, "z")
dat  <- db.locerase(dat, "f")
dat  <- db.locerase(dat, "code")
dat  <- db.locerase(dat, "sel")
dat  <- db.delete(dat, "sigma2")
# Definition du modèle
param <- param_IndFac_a; pref <- "N.a"
m     <- SPDE_param2model(param = param)
m     <- model.reduce(m, vars = 2, structs = 2)
dat   <- db.add(dat, sigma2 = param$sigma^2)

# Selection des variables
dat <- db.locate(dat, name = c("N"), loctype = "f", flag.locnew = TRUE)
dat <- db.locate(dat, name = c("S"), loctype = "z", flag.locnew = TRUE)
dat <- db.locate(dat, name = c("sigma2"), loctype = "v", flag.locnew = TRUE)
dat <- db.locate(dat, name = c("sel_train_a"), loctype = "sel", flag.locnew = TRUE)

grd <- LMOK_kriging(grd, dbin = dat, model = m, 
                    idx = NA, flag.estim = TRUE, flag.stdev = TRUE,
                    radix = paste("LMOK", pref, sep = "."), verbose = TRUE)
grd <- SPDE_LMOK_krigsim(grd, dbin = dat, model = m, 
                    nsim = 0, flag.ce = FALSE,
                    radix = paste("SPDE_LMOK", pref, sep = "."), verbose = TRUE)
grd <- SPDE_LMOK_krigsim(grd, dbin = dat, model = m, 
                    nsim = 1000, flag.ce = TRUE,
                    radix = paste("SPDE_LMOK", pref, sep = "."), verbose = TRUE)

correlation_LMOK(m, grd, pref, name1 = "LMOK", name2 = "SPDE_LMOK")
```

### Type (b)

```{r eval_LMOK_N_b, echo=TRUE, eval=TRUE}
# re-initialisation
dat  <- db.locerase(dat, "z")
dat  <- db.locerase(dat, "f")
dat  <- db.locerase(dat, "code")
dat  <- db.locerase(dat, "sel")
dat  <- db.delete(dat, "sigma2")
# Definition du modèle
param <- param_IndFac_b; pref <- "N.b"
m     <- SPDE_param2model(param = param)
m     <- model.reduce(m, vars = 2, structs = 2)
dat   <- db.add(dat, sigma2 = param$sigma^2)

# Selection des variables
dat <- db.locate(dat, name = c("N"), loctype = "f", flag.locnew = TRUE)
dat <- db.locate(dat, name = c("S"), loctype = "z", flag.locnew = TRUE)
dat <- db.locate(dat, name = c("sigma2"), loctype = "v", flag.locnew = TRUE)
dat <- db.locate(dat, name = c("sel_train_b"), loctype = "sel", flag.locnew = TRUE)

grd <- LMOK_kriging(grd, dbin = dat, model = m, 
                    idx = NA, flag.estim = TRUE, flag.stdev = TRUE,
                    radix = paste("LMOK", pref, sep = "."), verbose = TRUE)
grd <- SPDE_LMOK_krigsim(grd, dbin = dat, model = m, 
                    nsim = 0, flag.ce = FALSE,
                    radix = paste("SPDE_LMOK", pref, sep = "."), verbose = TRUE)
grd <- SPDE_LMOK_krigsim(grd, dbin = dat, model = m, 
                    nsim = 1000, flag.ce = TRUE,
                    radix = paste("SPDE_LMOK", pref, sep = "."), verbose = TRUE)

correlation_LMOK(m, grd, pref, name1 = "LMOK", name2 = "SPDE_LMOK")
```

# Mono-variable 

## Paramètres spatiaux indépendants

$$
S_k = Z_1(s_k) \times 1 + Z_2(s_k) \times N_k + \epsilon_k
$$
avec
$$
 \{Cov((Z_i(s), Z_j(s')\}_{i,j \in 1:2} = 
 \begin{pmatrix}
 \sigma_1^2            & 0 \\
 0                     & 0
 \end{pmatrix} \times \rho_1(s-s') +
 \begin{pmatrix}
 0                     & 0 \\
 0                     & \sigma_2^2  
 \end{pmatrix} \times \rho_2(s-s')
$$
### Données de type (a)

```{r eval_LMOK_a_Ind, echo=TRUE, eval=TRUE}
# re-initialisation
dat  <- db.locerase(dat, "z")
dat  <- db.locerase(dat, "f")
dat  <- db.locerase(dat, "code")
dat  <- db.locerase(dat, "sel")
dat  <- db.delete(dat, "sigma2")
# Definition du modèle
param <- param_IndFac_a; pref <- "Un_N.a"
m     <- SPDE_param2model(param = param)
dat   <- db.add(dat, sigma2 = param$sigma^2)

# Selection des variables
dat <- db.locate(dat, name = c("Un", "N"), loctype = "f", flag.locnew = TRUE)
dat <- db.locate(dat, name = c("S"), loctype = "z", flag.locnew = TRUE)
dat <- db.locate(dat, name = c("sigma2"), loctype = "v", flag.locnew = TRUE)
dat <- db.locate(dat, name = c("sel_train_a"), loctype = "sel", flag.locnew = TRUE)
grd <- LMOK_kriging(grd, dbin = dat, model = m, 
                    idx = 1:2, flag.estim = TRUE, flag.stdev = TRUE,
                    radix = paste("LMOK", pref, sep = "."), verbose = TRUE)
grd <- SPDE_LMOK_krigsim(grd, dbin = dat, model = m, mesh = NA,
                    nsim = 0, seed = NA, flag.ce = FALSE,
                    radix = paste("SPDE_LMOK", pref, sep = "."), verbose = TRUE)
grd <- SPDE_LMOK_krigsim(grd, dbin = dat, model = m, mesh = NA,
                    nsim = nsim, seed = NA, flag.ce = TRUE,
                    radix = paste("SPDE_LMOK", pref, sep = "."), verbose = TRUE)

correlation_LMOK(m, grd, pref, name1 = "LMOK", name2 = "SPDE_LMOK")
```

### Données de type (b) 
```{r eval_LMOK_b_Ind, echo=TRUE, eval=TRUE}
# re-initialisation
dat  <- db.locerase(dat, "z")
dat  <- db.locerase(dat, "f")
dat  <- db.locerase(dat, "code")
dat  <- db.locerase(dat, "sel")
dat  <- db.delete(dat, "sigma2")
# Definition du modèle
param <- param_IndFac_b; pref <- "Un_N.b"
m     <- SPDE_param2model(param = param)
dat   <- db.add(dat, sigma2 = param$sigma^2)

# Selection des variables
dat <- db.locate(dat, name = c("Un", "N"), loctype = "f", flag.locnew = TRUE)
dat <- db.locate(dat, name = c("S"), loctype = "z", flag.locnew = TRUE)
dat <- db.locate(dat, name = c("sigma2"), loctype = "v", flag.locnew = TRUE)
dat <- db.locate(dat, name = c("sel_train_b"), loctype = "sel", flag.locnew = TRUE)
grd <- LMOK_kriging(grd, dbin = dat, model = m, 
                    idx = 1:2, flag.estim = TRUE, flag.stdev = TRUE,
                    radix = paste("LMOK", pref, sep = "."), verbose = TRUE)
grd <- SPDE_LMOK_krigsim(grd, dbin = dat, model = m, mesh = NA,
                    nsim = 0, seed = NA, flag.ce = FALSE,
                    radix = paste("SPDE_LMOK", pref, sep = "."), verbose = TRUE)
grd <- SPDE_LMOK_krigsim(grd, dbin = dat, model = m, mesh = NA,
                    nsim = nsim, seed = NA, flag.ce = TRUE,
                    radix = paste("SPDE_LMOK", pref, sep = "."), verbose = TRUE)

correlation_LMOK(m, grd, pref, name1 = "LMOK", name2 = "SPDE_LMOK")
```

## Paramètres spatiaux en coregionalisation intrinsèque

$$
S_k = Z_1(s_k) \times 1 + Z_2(s_k) \times N_k +\epsilon_k
$$
avec
$$
 \{Cov((Z_i(s), Z_j(s')\}_{i,j \in 1:2} = \begin{pmatrix}
 \sigma_1^2            & \sigma_1\sigma_2\tau \\
 \sigma_1\sigma_2\tau  & \sigma_2^2  
 \end{pmatrix} \times \rho(s-s')
$$


### Données de type (a) 

```{r eval_LMOK_a_Int, echo=TRUE, eval=TRUE}
# re-initialisation
dat  <- db.locerase(dat, "z")
dat  <- db.locerase(dat, "f")
dat  <- db.locerase(dat, "code")
dat  <- db.locerase(dat, "sel")
dat  <- db.delete(dat, "sigma2")
# Definition du modèle
param <- param_IntFac_a; pref <- "Un_N.a.Int"
m     <- SPDE_param2model(param = param)
dat   <- db.add(dat, sigma2 = param$sigma^2)

# Selection des variables
dat <- db.locate(dat, name = c("Un", "N"), loctype = "f", flag.locnew = TRUE)
dat <- db.locate(dat, name = c("S"), loctype = "z", flag.locnew = TRUE)
dat <- db.locate(dat, name = c("sigma2"), loctype = "v", flag.locnew = TRUE)
dat <- db.locate(dat, name = c("sel_train_a"), loctype = "sel", flag.locnew = TRUE)
grd <- LMOK_kriging(grd, dbin = dat, model = m, 
                    idx = 1:2, flag.estim = TRUE, flag.stdev = TRUE,
                    radix = paste("LMOK", pref, sep = "."), verbose = TRUE)
grd <- SPDE_LMOK_krigsim(grd, dbin = dat, model = m, mesh = NA,
                    nsim = 0, seed = NA, flag.ce = FALSE,
                    radix = paste("SPDE_LMOK", pref, sep = "."), verbose = TRUE)
grd <- SPDE_LMOK_krigsim(grd, dbin = dat, model = m, mesh = NA,
                    nsim = nsim, seed = NA, flag.ce = TRUE,
                    radix = paste("SPDE_LMOK", pref, sep = "."), verbose = TRUE)

correlation_LMOK(m, grd, pref, name1 = "LMOK", name2 = "SPDE_LMOK")
```


### Données de type (b) 

```{r eval_LMOK_b_Int, echo=TRUE, eval=TRUE}
# re-initialisation
dat  <- db.locerase(dat, "z")
dat  <- db.locerase(dat, "f")
dat  <- db.locerase(dat, "code")
dat  <- db.locerase(dat, "sel")
dat  <- db.delete(dat, "sigma2")
# Definition du modèle
param <- param_IntFac_b; pref <- "Un_N.b.Int"
m     <- SPDE_param2model(param = param)
dat   <- db.add(dat, sigma2 = param$sigma^2)

# Selection des variables
dat <- db.locate(dat, name = c("Un", "N"), loctype = "f", flag.locnew = TRUE)
dat <- db.locate(dat, name = c("S"), loctype = "z", flag.locnew = TRUE)
dat <- db.locate(dat, name = c("sigma2"), loctype = "v", flag.locnew = TRUE)
dat <- db.locate(dat, name = c("sel_train_b"), loctype = "sel", flag.locnew = TRUE)
grd <- LMOK_kriging(grd, dbin = dat, model = m, 
                    idx = 1:2, flag.estim = TRUE, flag.stdev = TRUE,
                    radix = paste("LMOK", pref, sep = "."), verbose = TRUE)
grd <- SPDE_LMOK_krigsim(grd, dbin = dat, model = m, mesh = NA,
                    nsim = 0, seed = NA, flag.ce = FALSE,
                    radix = paste("SPDE_LMOK", pref, sep = "."), verbose = TRUE)
grd <- SPDE_LMOK_krigsim(grd, dbin = dat, model = m, mesh = NA,
                    nsim = nsim, seed = NA, flag.ce = TRUE,
                    radix = paste("SPDE_LMOK", pref, sep = "."), verbose = TRUE)

correlation_LMOK(m, grd, pref, name1 = "LMOK", name2 = "SPDE_LMOK")
```

# Cas bi-variable

$$
S^{(a)}_k = Z_1(s_k) \times 1 + Z_2(s_k) \times N^{(a)}_k +\epsilon^{(a)}_k
$$
et
$$
S^{(b)}_k = Z_3(s_k) \times 1 + Z_4(s_k) \times N^{(b)}_k +\epsilon^{(b)}_k
$$

avec

$$
Cov(Z_i(s), Z_j(s')) = 
 \begin{pmatrix}
 \sigma_1^2            & \sigma_1\sigma_2\tau & 0 & 0 \\
 \sigma_1\sigma_2\tau  & \sigma_2^2 & 0 & 0 \\  
 0                     & 0                    & 0  & 0 \\
 0                     & 0                    & 0  & 0 
 \end{pmatrix} 
 \times \rho_a(s-s')+
\begin{pmatrix}
 0                     & 0                    & 0  & 0 \\
 0                     & 0                    & 0  & 0 \\
 0 & 0 & \sigma_3^2            & \sigma_3\sigma_4\tau' \\
 0 & 0 & \sigma_3\sigma_4\tau'  & \sigma_4^2  
 \end{pmatrix} 
 \times \rho_b(s-s')

$$

Définition des facteurs dans le cas bivariable

```{r LMOK_bivar_ini, echo=TRUE, eval=TRUE}
Un.a <- rep(0, dat$nech)
Un.a[dat$Type == 1] <- 1.0
Un.b <- rep(0, dat$nech)
Un.b[dat$Type == 2] <- 1.0
N.a  <- rep(0.0, dat$nech)
N.a[dat$Type == 1] <- dat$N[dat$Type == 1]
N.b  <- rep(0.0, dat$nech)
N.b[dat$Type == 2] <- dat$N[dat$Type == 2]
dat   <- db.add(dat, Un.a, Un.b, N.a, N.b)
```


## Paramètres spatiaux indépendants

```{r eval_LMOK_BiInd, echo=TRUE, eval=TRUE}
# re-initialisation
dat  <- db.locerase(dat, "z")
dat  <- db.locerase(dat, "f")
dat  <- db.locerase(dat, "code")
dat  <- db.locerase(dat, "sel")
dat  <- db.delete(dat, "sigma2")
# Definition du modèle : Bi-variable avec facteurs indépendants
param <- param_CoefBi_ind; pref <- "BiInd" 
m     <- SPDE_param2model(param = param)
sigma2 <- rep(NaN, dat$nech)
sigma2[dat$Type == 1] <- param$sigma[1]^2
sigma2[dat$Type == 2] <- param$sigma[2]^2
dat   <- db.add(dat, sigma2)

# Selection des variables
dat <- db.locate(dat, name = c("sel_train"), loctype = "sel", flag.locnew = TRUE)
dat <- db.locate(dat, name = c("Un.a", "Un.b", "N.a", "N.b"), loctype = "f", flag.locnew = TRUE)
dat <- db.locate(dat, name = c("S"), loctype = "z", flag.locnew = TRUE)
dat <- db.locate(dat, name = c("sigma2"), loctype = "v", flag.locnew = TRUE)

grd <- LMOK_kriging(grd, dbin = dat, model = m, 
                    idx = NA, flag.estim = TRUE, flag.stdev = TRUE,
                    radix = paste("LMOK", pref, sep = "."), verbose = TRUE)
grd <- SPDE_LMOK_krigsim(grd, dbin = dat, model = m,
                    nsim = 0, flag.ce = FALSE,
                    radix = paste("SPDE_LMOK", pref, sep = "."), verbose = TRUE)
grd <- SPDE_LMOK_krigsim(grd, dbin = dat, model = m,
                    nsim = 1000, flag.ce = TRUE,
                    radix = paste("SPDE_LMOK", pref, sep = "."), verbose = TRUE)

correlation_LMOK(m, grd, pref, name1 = "LMOK", name2 = "SPDE_LMOK")
```

## Paramètres spatiaux en coregionalisation intrinsèque

```{r eval_LMOK_BiInt, echo=TRUE, eval=TRUE}
# re-initialisation
dat  <- db.locerase(dat, "z")
dat  <- db.locerase(dat, "f")
dat  <- db.locerase(dat, "code")
dat  <- db.locerase(dat, "sel")
dat  <- db.delete(dat, "sigma2")
# Definition du modèle : Bi-variable en corrélation intrinsèque
param <- param_CoefBi; pref <- "BiInt" 
m     <- SPDE_param2model(param = param)
sigma2 <- rep(NaN, dat$nech)
sigma2[dat$Type == 1] <- param$sigma[1]^2
sigma2[dat$Type == 2] <- param$sigma[2]^2
dat   <- db.add(dat, sigma2)

# Selection des variables
dat <- db.locate(dat, name = c("sel_train"), loctype = "sel", flag.locnew = TRUE)
dat <- db.locate(dat, name = c("Un.a", "Un.b", "N.a", "N.b"), loctype = "f", flag.locnew = TRUE)
dat <- db.locate(dat, name = c("S"), loctype = "z", flag.locnew = TRUE)
dat <- db.locate(dat, name = c("sigma2"), loctype = "v", flag.locnew = TRUE)

grd <- LMOK_kriging(grd, dbin = dat, model = m, 
                    idx = NA, flag.estim = TRUE, flag.stdev = TRUE,
                    radix = paste("LMOK", pref, sep = "."), verbose = TRUE)
grd <- SPDE_LMOK_krigsim(grd, dbin = dat, model = m,
                    nsim = 0, flag.ce = FALSE,
                    radix = paste("SPDE_LMOK", pref, sep = "."), verbose = TRUE)
grd <- SPDE_LMOK_krigsim(grd, dbin = dat, model = m,
                    nsim = 1000, flag.ce = TRUE,
                    radix = paste("SPDE_LMOK", pref, sep = "."), verbose = TRUE)

correlation_LMOK(m, grd, pref, name1 = "LMOK", name2 = "SPDE_LMOK")
```

# Calcul de la vraisemblance

```{r eval_MLL, echo=TRUE, eval=TRUE}
#' ------------------------------------------------------------
#'  Auxiliary function: 1_N.Ind (Two independant factors)
#' x[1] = sigma_1 (Standard deviation of Z_1)
#' x[2] = range_1 (Practical range of Z_1)
#' x[3] = sigma_2 (Standard deviation of Z_2)
#' x[4] = range_2 (Practical range of Z_2)
#' x[5] = sigma   (Standard deviation of the measurement error)
#' ------------------------------------------------------------

create_model_BiFInd <- function(x, verbose = TRUE){
  nu = 3.0
  model <- model.create(8, range = x[2], sill = matrix(c(x[1]^2,0,0,0),2,2))
  model <- model.create(8, range = x[4], sill = matrix(c(0,0,0,x[3]^2),2,2), 
                        model = model)
  if (verbose){
    print(model)
    print(paste0("sigma = ", x[5]))
  }
  list(model = model, sigma = x[5])
}
# illustration
x <- c(param_IndFac_a$sigma_1, param_IndFac_a$range_1,
       param_IndFac_a$sigma_2, param_IndFac_a$range_2,
       param_IndFac_a$sigma)
create_model_BiFInd(x, verbose = TRUE)

# re-initialisation de la base de données
dat  <- db.locerase(dat, "z")
dat  <- db.locerase(dat, "f")
dat  <- db.locerase(dat, "code")
dat  <- db.locerase(dat, "sel")
dat  <- db.delete(dat, "sigma2")
# Selection des variables
dat <- db.locate(dat, name = c("Un", "N"), loctype = "f", flag.locnew = TRUE)
dat <- db.locate(dat, name = c("S"), loctype = "z", flag.locnew = TRUE)
dat <- db.locate(dat, name = c("sel_train_a"), loctype = "sel", flag.locnew = TRUE)

fn_MLL <- SPDE_LMOK_init_MLL(dat, param2model = create_model_BiFInd, verbose = FALSE)
fn_MLL(x, verbose = FALSE)

#' ------------------------------------------------------------
#'  Auxiliary function: BiInt (intrinsic coregionalisation of the two factors)
#' x[1] = sigma_1 (Standard deviation of Z_1)
#' x[2] = sigma_2 (Standard deviation of Z_2)
#' x[3] = tau     (correlation coefficient between the two factors)
#' x[4] = range   (Practical range of the factors)
#' x[5] = sigma   (Standard deviation of the measurement error)
#' ------------------------------------------------------------

create_model_BiFInt <- function(x, verbose = TRUE){
  nu = 3.0
  c0 <- matrix(c(x[1]^2, rep(prod(x[1:3]), 2), x[2]^2), 2, 2)
  model <- model.create(8, range = x[4], sill = c0)
  if (verbose){
    print(model)
    print(paste0("sigma = ", x[5]))
  }
  list(model = model, sigma = x[5])
}
# illustration
x <- c(param_IntFac_a$sigma_1,
       param_IntFac_a$sigma_2,
       param_IntFac_a$tau,
       param_IntFac_a$range,
       param_IntFac_a$sigma)
create_model_BiInt(x, verbose = TRUE)

# re-initialisation de la base de données
dat  <- db.locerase(dat, "z")
dat  <- db.locerase(dat, "f")
dat  <- db.locerase(dat, "code")
dat  <- db.locerase(dat, "sel")
dat  <- db.delete(dat, "sigma2")
# Selection des variables
dat <- db.locate(dat, name = c("Un", "N"), loctype = "f", flag.locnew = TRUE)
dat <- db.locate(dat, name = c("S"), loctype = "z", flag.locnew = TRUE)
dat <- db.locate(dat, name = c("sel_train_a"), loctype = "sel", flag.locnew = TRUE)

# Creation of the function computing the log-likelihood
fn_MLL2 <- SPDE_LMOK_init_MLL(dat, param2model = create_model_BiFInt, verbose = FALSE)
fn_MLL2(x, verbose = FALSE)

#' ------------------------------------------------------------
#' Auxiliary function: bivar (intrinsic coregionalisation of the factors)
#' Factors: F1 = "indicator of type == a"
#'          F2 = "indicator of type == b"
#'          F3 = "N x indicator of type == a"
#'          F4 = "N x indicator of type == b"
#'          
#' x[1] = sigma_1 Standard deviation of Z_1) F1
#' x[2] = sigma_2 Standard deviation of Z_2) F2
#' x[3] = sigma_3 Standard deviation of Z_3) F3
#' x[4] = sigma_4 Standard deviation of Z_4) F4
#' x[5] = tau_1   correlation coefficient between F1 and F2
#' x[6] = tau_2   correlation coefficient between F3 and F4
#' x[7] = range_1 range of spatial structure of F1 and F2
#' x[8] = range_2 range of spatial structure of F3 and F4
#' x[9] = sigma_a Standard deviation of the measurement error for type == a
#' x[10] = sigma_b Standard deviation of the measurement error for type == b
#' ------------------------------------------------------------

create_model_bivar <- function(x, verbose = TRUE){
  nu = 3.0
  # F1 and F3
  c1 <- as.matrix(rbind(
    cbind(matrix(c(x[1]^2, rep(x[1]*x[2]*x[5], 2), x[2]^2), 2, 2),
          matrix(0.0,2,2)),
    matrix(0.0, 2, 4)))
  
  model <- model.create(8, range = x[7], sill = c1)
  
  c2 <- as.matrix(rbind(
    matrix(0.0,2,4),
    cbind(matrix(0.0, 2,2), 
          matrix(c(x[3]^2, rep(x[3]*x[4]*x[6], 2), x[4]^2), 2, 2))))
  model <- model.create(8, range = x[8], sill = c2, model = model)
  
  if (verbose){
    print(model)
    print(paste0("sigma_a = ", x[9]))
    print(paste0("sigma_b = ", x[10]))
  }
  list(model = model, sigma = c(x[9], x[10]))
}
# re-initialisation de la base de données
dat  <- db.locerase(dat, "z")
dat  <- db.locerase(dat, "f")
dat  <- db.locerase(dat, "code")
dat  <- db.locerase(dat, "sel")
dat  <- db.delete(dat, "sigma2")
# Selection des variables
dat <- db.locate(dat, names = "sel_train", loctype = "sel", flag.locnew = TRUE)
dat <- db.locate(dat, names = "Type", loctype = "code", flag.locnew = TRUE)
dat <- db.locate(dat, names = "S", loctype = "z", flag.locnew = TRUE)
dat <- db.locate(dat, names = c("Un.a", "Un.b", "N.a", "N.b"), loctype = "f", flag.locnew = TRUE)

fn_MLL_bivar <- SPDE_LMOK_init_MLL(dat, param2model = create_model_bivar, verbose = FALSE)


# illustration # coregionalisation intrinsèque
x <- c(
  param_CoefBi$coef_1[1:2], 
  param_CoefBi$coef_2[1:2], 
  param_CoefBi$coef_1[3],
  param_CoefBi$coef_2[3],
  param_CoefBi$range,
  param_CoefBi$sigma)

fn_MLL_bivar(x, verbose = FALSE)

# illustration # indépendance des facteurs
x <- c(
  param_CoefBi$coef_1[1:2], 
  param_CoefBi$coef_2[1:2], 
  0.0, 
  0.0,
  param_CoefBi$range,
  param_CoefBi$sigma)

fn_MLL_bivar(x, verbose = FALSE)
```


