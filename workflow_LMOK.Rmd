---
  title: "Workflow LMOK"
  author: "X. Freulon, N. Desassis, H. Wackernagel"
  date: "12 août 2022"
  output:
    pdf_document: default
    html_document: default
---

# Initialisation

R et RGeostats

```{r R_init, echo=TRUE, eval=TRUE}
knitr::opts_chunk$set(echo = TRUE)
library(RGeostats)
library(Matrix)
rm(list=ls())
constant.define("asp",1)

```

Paramétrage 

```{r}
set.seed(seed=125875)
nsim = 1000 # Number of simulations to compute CE
np = 100    # Number of samples in the training data base
n.fold = 10 # Number of folds for the cross-validation
nm_var = "S_cap"
nm_fac = "NB_cap"
nm_sel = "sel_flat"
type = "flat"
```

LMOK fonctions

```{r LMOK_init, echo = TRUE, eval=TRUE}
source(file = "./functions_spde.R")
source(file = "./functions_draw_data.R")
source(file = "./functions_Xval.R")
```

```{r}
load(file = "../Data/CCR_69.Rdata")
dat = db.add(dat, tempsel = C1NATURE == ifelse(type=="flat",2,1))
dat = db.rename(dat,"tempsel",nm_sel)

dat = db.add(dat,Un = 1.)

```

#Definition du modèle


```{r Model_init, echo = TRUE, eval = TRUE}
# Paramètres du modèle

nu      <- 1        # Coefficient de la covariance de Matern
nodes   <- c(100,100) # Valeur par default pour le meshing
margin  <- 0.2      # Proportion pour l'extension de la zone à mailler


# required in SPDE_LMOK_init_geometry if mesh not provided
param <- list(margin = margin, nodes = nodes, nu = nu)


```



```{r MLOK_MLL_ini, echo=TRUE, eval=TRUE}

param_ini <- list(nodes   = nodes, margin  = margin,
  type = "IndFac", 
  nu = nu,
  sigma_0 = 10,
  sigma_1 = 10,
  sigma   = 10,
  range_0 = 10000,
  range_1 = 10000
)

#' ------------------------------------------------------------
#'  Auxiliary function: BiInt (intrinsic coregionalisation of the two factors)
#' x[1] = sigma_1 (Standard deviation of Z_1)
#' x[2] = range_1 (Practical range of Z_1)
#' x[3] = sigma_2 (Standard deviation of Z_2)
#' x[4] = range_1 (Practical range of Z_2)
#' x[5] = sigma   (Standard deviation of the measurement error)
#' ------------------------------------------------------------
create_model_flat_indep <- function(x, verbose = TRUE){
  nu = param$nu
  c0 <- matrix(c(x[1]^2, rep(0,3)),nrow=2)
  model <- model.create(8, range = abs(x[2]), sill = c0)
  c1 <- matrix(c(rep(0,3),x[3]^2),nrow=2)
  model <- model.create(8, range = abs(x[4]), sill = c1,model=model)
  if (verbose){
    print(model)
    print(paste0("sigma = ", x[5]))
  }
  list(model = model, sigma = x[5])
}

x_ini_flat_indep = c(param_ini$sigma_0,param_ini$range_0,param_ini$sigma_1,param_ini$range_1,param_ini$sigma)

cont_flat_indep = list(fnscale = 1,parscale = c(1,100000,1,100000,1), ndeps=rep(1,5)*1e-4,trace = 1, maxit=200,REPORT=1)

namesParam_flat_indep = c("sigma_1", "range_1", "sigma_2", "range_2", "sigma")
```


```{r}
cont = cont_flat_indep
x_ini = x_ini_flat_indep
modelMulti = create_model_flat_indep
namesParam = namesParam_flat_indep
```

```{r}

# illustration avec les paramètres de simulation
modelMulti(x_ini, verbose = TRUE)

# re-initialisation de la base de données
dat  <- db.locerase(dat, "z")
dat  <- db.locerase(dat, "f")
dat  <- db.locerase(dat, "code")
dat  <- db.locerase(dat, "sel")
dat  <- db.delete(dat, "sigma2")
# Selection des variables
dat <- db.locate(dat, name = c("Un", nm_fac), loctype = "f", flag.locnew = TRUE)
dat <- db.locate(dat, name = c(nm_var), loctype = "z", flag.locnew = TRUE)
dat = db.locate(dat,nm_sel,"sel")
#dat <- db.locate(dat, name = c("sel_train"), loctype = "sel", flag.locnew = TRUE)

# Creation of the function computing the log-likelihood
fn_MLL <- SPDE_LMOK_init_MLL(dat, param2model = modelMulti, verbose = FALSE)
# Valeurs à l'initialisation
fn_MLL(x_ini, verbose = TRUE)
```

Optimisation de la vraisemblance

```{r LMOK_MLL, eval=TRUE, echo=FALSE}
res   <- optim(par = x_ini, fn = fn_MLL, verbose=F, method="Nelder-Mead", control = cont)

x_est <- res$par
#x_est <- x_ini

tab <- rbind(x_ini, x_est)
colnames(tab) <- namesParam
rownames(tab) <- c("Initial", "Final")
knitr::kable(round(tab,2), caption = "Maximum de vraisemblance")

# creation of the model and measurement error variable
res   <- modelMulti(x_est, verbose = TRUE)
m_est <- res$model
dat   <- db.delete(dat, names = "sigma2") # To prevent duplicate
dat   <- db.add(dat, sigma2  =  res$sigma^2)
dat   <- db.locate(dat, names = "sigma2", loctype = "v", flag.locnew = TRUE)
```

# Validation croisée par K-fold

Le nombre de *folds* est fixé à $K$.

```{r LMOK_kfold, echo=TRUE, eval=TRUE}
# Creation of the folds for the cross-validation
dat <- db.add(dat, folds = sample(x = 1:n.fold, size = dat$nech, replace = TRUE))
dat <- db.locate(dat, names = "folds", loctype = "code", flag.locnew = TRUE)
# 
dat <- db.locerase(dat, loctype = "sel")
dat <- db.locate(dat, names = nm_var, loctype = "z", flag.locnew = TRUE)
dat <- db.locate(dat, names = c("Un", nm_fac), loctype = "f", flag.locnew = TRUE)
dat <- db.locate(dat, names = "sigma2", loctype = "v", flag.locnew = TRUE)
dat = db.locate(dat,nm_sel,"sel")

# calcul de la validation par K-fold
datXval <- SPDE_LMOK_kfold_compute(dat, model = m_est, verbose = TRUE, radix = "kfold")

# calcul de la validation par K-fold
tab <- SPDE_LMOK_kfold_results(datXval, name_real = nm_var, name_esti = "kfold.S.estim", flag.fig = TRUE, stats = c("number", "min", "max", "mean", "MAE", "RMSE"))
knitr::kable(round(tab,2), caption = paste0("Validation croisée par K-fold (K=", n.fold,")"))

# Map of the absolute value of the validation residual
datXval <- db.add(datXval, AResidual = abs(dat[,nm_var] - dat[,"kfold.S.estim"]))

# The map is computed on a regular grid 1x1 km^2
dat.grd <- db.grid.init(datXval, dcell = rep(0.1, 2))
dat.grd <- db.stat.grid(datXval, dat.grd, fun = "mini")
dat.grd <- db.rename(dat.grd, names = "Stats.AResidual", newnames = "Minimum of residual")
plot(dat.grd, pos.legend = 3)
# data cleaning
dat <- db.delete(dat, names = "AResidual")
```


# Estimation des coefficients

Toutes les données disponibles sont maintenant utilisées.

```{r LMOK_eval, echo=TRUE, eval=TRUE}
# re-initialisation
dat  <- db.locerase(dat, "sel")
dat  <- db.locerase(dat, "z")
dat  <- db.locerase(dat, "f")
dat  <- db.locerase(dat, "v")
dat  <- db.locerase(dat, "code")

# Selection des variables
dat <- db.locate(dat, name = c("Un", nm_fac), loctype = "f", flag.locnew = TRUE)
dat <- db.locate(dat, name = c(nm_var), loctype = "z", flag.locnew = TRUE)
dat <- db.locate(dat, name = c("sigma2"), loctype = "v", flag.locnew = TRUE)

pref<- paste(nm_var, "Int", sep = ".")
grd <- SPDE_LMOK_krigsim(grd, dbin = dat, model = m_est, mesh = NA,
                    nsim = 0, seed = NA, flag.ce = FALSE,
                    radix = paste("SPDE_LMOK", pref, sep = "."), verbose = TRUE)
grd <- SPDE_LMOK_krigsim(grd, dbin = dat, model = m_est, mesh = NA,
                    nsim = nsim, seed = NA, flag.ce = TRUE,
                    radix = paste("SPDE_LMOK", pref, sep = "."), verbose = TRUE)
```


# Presentation des résultats

```{r LMOK_results, echo=TRUE, eval=TRUE}
# map of the estimated values
plot(grd, name = paste("SPDE_LMOK", pref, "Z1", "estim", sep = "."), pos.legend = 8)
plot(dat, name = nm_var, add = TRUE)
plot(grd, name = paste("SPDE_LMOK", pref, "Z2", "estim", sep = "."), pos.legend = 8)
plot(dat, name = nm_var, add = TRUE)
# map of the standard deviation of the estimation error
plot(grd, name = paste("SPDE_LMOK", pref, "Z1", "ce.stdev", sep = "."), pos.legend = 8)
plot(dat, name = nm_var, add = TRUE)
plot(grd, name = paste("SPDE_LMOK", pref, "Z2", "ce.stdev", sep = "."), pos.legend = 8)
plot(dat, name = nm_var, add = TRUE)
# statistics
tab <- db.stat.multi(grd, names = "SPDE_LMOK.*")
knitr::kable(round(tab,2), caption = "Estimation des coefficients")
