---
  title: "Workflow LMOK"
  author: "X. Freulon, N. Desassis, H. Wackernagel"
  date: "12 août 2022"
  output:
    pdf_document: default
    html_document: default
---

# Initialisation

R et RGeostats

```{r R_init, echo=TRUE, eval=TRUE}
knitr::opts_chunk$set(echo = TRUE)
library(RGeostats)
library(Matrix)
rm(list=ls())
constant.define("asp",1)

```

Paramétrage 


```{r Model_init, echo = TRUE, eval = TRUE}
# Paramètres du modèle

nu      <- 1        # Coefficient de la covariance de Matern
nodes   <- c(100,100) # Valeur par default pour le meshing
margin  <- 0.2      # Proportion pour l'extension de la zone à mailler


# required in SPDE_LMOK_init_geometry if mesh not provided
param <- list(margin = margin, nodes = nodes, nu = nu)


```


```{r}
set.seed(seed=125875)
nsim = 1000 # Number of simulations to compute CE
np = 100    # Number of samples in the training data base
n.fold = 10 # Number of folds for the cross-validation
nm_var = "S_cap"
nm_fac = "NB_cap"
nm_type = "C1NATURE"
nm_sel = "sel_flat"

# Choose model type among the next combinations

#source("./M1.R");type = "flat"
#source("./M1.R");type = "house"

source("./M3.R");type = "both"
```

LMOK fonctions

```{r LMOK_init, echo = TRUE, eval=TRUE}
source(file = "./functions_spde.R")
source(file = "./functions_draw_data.R")
source(file = "./functions_Xval.R")
source(file = "./prepareDb.R")
```

```{r}
load(file = "../Data/CCR_69.Rdata")
dat = prepareDb(dat,nm_fac,nm_var,nm_sel,nm_type,type)
```

#Definition du modèle


```{r}
coords = read.csv("meshCoords.ascii")
pts = db.create(x1=coords[,2],x2=coords[,3])
mesh = meshing(pts,triswitch="nqQ")
plot(mesh,lwd=0.1)
plot(poly,add=T)
```


```{r}

# illustration avec les paramètres de simulation
modelMulti(x_ini, verbose = TRUE)


# Creation of the function computing the log-likelihood
fn_MLL <- SPDE_LMOK_init_MLL(dat, param2model = modelMulti, verbose = FALSE,mesh=mesh)
# Valeurs à l'initialisation
fn_MLL(x_ini, verbose = TRUE)
```

Optimisation de la vraisemblance


```{r}
res   <- optim(par = x_ini, fn = fn_MLL, verbose = F, method="Nelder-Mead", control = cont)
x_est = res$par
```

```{r LMOK_MLL, eval=TRUE, echo=FALSE}
#res   <- optim(par = x_est, fn = fn_MLL, verbose=F, method="Nelder-Mead", control = cont)
#x_est <- res$par


tab <- rbind(x_ini, x_est)
colnames(tab) <- namesParam
rownames(tab) <- c("Initial", "Final")
knitr::kable(round(tab,2), caption = "Maximum de vraisemblance")

# creation of the model and measurement error variable
resModel   <- modelMulti(x_est, verbose = TRUE)
m_est <- resModel$model

```

# Validation croisée par K-fold

Le nombre de *folds* est fixé à $K$.

```{r LMOK_kfold, echo=TRUE, eval=TRUE}
# Creation of the folds for the cross-validation
dat = prepareDb(dat,nm_fac,nm_var,nm_sel,nm_type,type,resModel$sigma)
datXval <- db.add(dat, folds = sample(x = 1:n.fold, size = dat$nech, replace = TRUE))


# calcul de la validation par K-fold
datXval <- SPDE_LMOK_kfold_compute(datXval, model = m_est, verbose = TRUE, radix = "kfold", mesh = mesh)

# calcul de la validation par K-fold
tab <- SPDE_LMOK_kfold_results(datXval, name_real = nm_var, name_esti = "kfold.S.estim", flag.fig = TRUE, stats = c("number", "min", "max", "mean", "MAE", "RMSE"))
knitr::kable(round(tab,2), caption = paste0("Validation croisée par K-fold (K=", n.fold,")"))

# Map of the absolute value of the validation residual
datXval <- db.add(datXval, AResidual = abs(datXval[,nm_var] - datXval[,"kfold.S.estim"]))

# The map is computed on a regular grid 1x1 km^2
dat.grd <- db.grid.init(datXval, dcell = rep(1000, 2))
dat.grd <- db.stat.grid(datXval, dat.grd, fun = "mini")
dat.grd <- db.rename(dat.grd, names = "Stats.AResidual", newnames = "Minimum of residual")
plot(dat.grd, pos.legend = 3)
```


# Estimation des coefficients

Toutes les données disponibles sont maintenant utilisées.

```{r LMOK_eval, echo=TRUE, eval=TRUE}
# re-initialisation
dat  <- db.locerase(dat, "sel")
dat  <- db.locerase(dat, "z")
dat  <- db.locerase(dat, "f")
dat  <- db.locerase(dat, "v")
dat  <- db.locerase(dat, "code")

# Selection des variables
dat <- db.locate(dat, name = c("Un", nm_fac), loctype = "f", flag.locnew = TRUE)
dat <- db.locate(dat, name = c(nm_var), loctype = "z", flag.locnew = TRUE)
dat <- db.locate(dat, name = c("sigma2"), loctype = "v", flag.locnew = TRUE)
dat = db.locate(dat,nm_sel,"sel")

grd = db.grid.init(dat,nodes=c(200,200))
grd=db.polygon(grd,dpts[[1]]$polygon )
pref<- paste(nm_var, "Int", sep = ".")
grd <- SPDE_LMOK_krigsim(grd, dbin = dat, model = m_est, mesh = mesh,
                    nsim = 0, seed = NA, flag.ce = FALSE,
                    radix = paste("SPDE_LMOK", pref, sep = "."), verbose = TRUE)
grd <- SPDE_LMOK_krigsim(grd, dbin = dat, model = m_est, mesh = mesh,
                    nsim = nsim, seed = NA, flag.ce = TRUE,
                    radix = paste("SPDE_LMOK", pref, sep = "."), verbose = TRUE)
```


# Presentation des résultats

```{r LMOK_results, echo=TRUE, eval=TRUE}
# map of the estimated values
plot(grd, name = paste("SPDE_LMOK", pref, "Z1", "estim", sep = "."))
#plot(dat, name = nm_var, add = TRUE)
plot(grd, name = paste("SPDE_LMOK", pref, "Z2", "estim", sep = "."), pos.legend = 8)
#plot(dat, name = nm_var, add = TRUE)
# map of the standard deviation of the estimation error
plot(grd, name = paste("SPDE_LMOK", pref, "Z1", "ce.stdev", sep = "."), pos.legend = 8)
#plot(dat, name = nm_var, add = TRUE)
plot(grd, name = paste("SPDE_LMOK", pref, "Z2", "ce.stdev", sep = "."), pos.legend = 8)
#plot(dat, name = nm_var, add = TRUE)
# statistics
tab <- db.stat.multi(grd, names = "SPDE_LMOK.*")
knitr::kable(round(tab,2), caption = "Estimation des coefficients")
```