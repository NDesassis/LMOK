---
  title: "Workflow LMOK"
  author: "X. Freulon, N. Desassis, H. Wackernagel"
  date: "12 août 2022"
  output:
    pdf_document: default
    html_document: default
---

# Initialisation

R et RGeostats

```{r R_init, echo=TRUE, eval=TRUE}
knitr::opts_chunk$set(echo = TRUE)
library(RGeostats)
library(Matrix)
rm(list=ls())
constant.define("asp",1)

```

Paramétrage 


```{r Model_init, echo = TRUE, eval = TRUE}
# Paramètres du modèle

nu      <- 1        # Coefficient de la covariance de Matern
nodes   <- c(100,100) # Valeur par default pour le meshing
margin  <- 0.2      # Proportion pour l'extension de la zone à mailler

# required in SPDE_LMOK_init_geometry if mesh not provided
param <- list(margin = margin, nodes = nodes, nu = nu)
```


```{r}
set.seed(seed=125875)

nsim = 1000 # Number of simulations to compute CE
np = 100    # Number of samples in the training data base
n.fold = 10 # Number of folds for the cross-validation
nm_var = "S_cap"
nm_fac = "NB_cap"
nm_type = "C1NATURE"

# Choose model type among the next combinations
#source("./M1.R");type = "flat"; nm_sel = "sel_flat"; nm_model = "flat_M1"
#source("./M1.R");type = "house"; nm_sel = "sel_house"; nm_model = "house_M1"
 source("./M2.R");type = "flat"; nm_sel = "sel_flat"; nm_model = "flat_M2"
#source("./M2.R");type = "house"; nm_sel = "sel_house"; nm_model = "house_M2"
#source("./M3.R");type = "both"; nm_sel = "sel_both";nm_model = "M3"
```

LMOK fonctions

```{r LMOK_init, echo = TRUE, eval=TRUE}
source(file = "./functions_spde.R")
source(file = "./functions_draw_data.R")
source(file = "./functions_Xval.R")
source(file = "./prepareDb.R")
```

```{r}
load(file = "../Data/CCR_69.Rdata")
dat = prepareDb(dat,nm_fac,nm_var,nm_sel,nm_type,type)
folds = sample(x = 1:n.fold, size = dat$nech, replace = TRUE)
```

#Definition du modèle


```{r}
coords = read.csv("meshCoords.ascii")
pts = db.create(x1=coords[,2],x2=coords[,3])
mesh = meshing(pts,triswitch="nqQ")
plot(mesh,lwd=0.1)
plot(poly,add=T)
```


```{r}
# illustration avec les paramètres de simulation
modelMulti(x_ini, verbose = TRUE)


# Creation of the function computing the log-likelihood
fn_MLL <- SPDE_LMOK_init_MLL(dat, param2model = modelMulti, verbose = FALSE,mesh=mesh)
# Valeurs à l'initialisation
fn_MLL(x_ini, verbose = TRUE)
```

Optimisation de la vraisemblance


```{r}
res   <- optim(par = x_ini, fn = fn_MLL, verbose = F, method="Nelder-Mead", control = cont)
x_est = res$par
```

```{r LMOK_MLL, eval=TRUE, echo=FALSE}
#res   <- optim(par = x_est, fn = fn_MLL, verbose=F, method="Nelder-Mead", control = cont)
#x_est <- res$par


tab <- rbind(x_ini, x_est)
colnames(tab) <- namesParam
rownames(tab) <- c("Initial", "Final")
knitr::kable(round(tab,2), caption = "Maximum de vraisemblance")

# creation of the model and measurement error variable
resModel   <- modelMulti(x_est, verbose = TRUE)
m_est <- resModel$model

```

# Validation croisée par K-fold

Le nombre de *folds* est fixé à $K$.

```{r LMOK_kfold, echo=TRUE, eval=TRUE}
# Creation of the folds for the cross-validation
dat = prepareDb(dat, 
                nm_fac = nm_fac,
                nm_var = nm_var, 
                nm_sel = nm_sel,
                nm_type = nm_type,
                type = type,
                sigma = resModel$sigma)
datXval <- db.add(dat, folds)
datXval <- db.locate(datXval, names = "folds", loctype = "code", flag.locnew = TRUE)
datXval <- db.locate(datXval, names = nm_var, loctype = "z", flag.locnew = TRUE)

# calcul de la validation par K-fold
datXval <- SPDE_LMOK_kfold_compute(datXval, model = m_est, verbose = TRUE, radix = "kfold", mesh = mesh)

# calcul de la validation par K-fold
tab <- SPDE_LMOK_kfold_results(datXval, name_real = nm_var, name_esti = "kfold.S.estim", flag.fig = TRUE, stats = c("number", "min", "max", "mean", "MAE", "RMSE"))

# if the Xval is computed on house and flat (model M3)
if(length(db.getcols(datXval, "f")) > 2){
  for (i in 1:2){
    tab <- rbind(tab,
                 SPDE_LMOK_kfold_results(
                   db.sel(datXval, combine = "and", datXval[,nm_type] == i),
                   name_real = nm_var, name_esti = "kfold.S.estim", flag.fig = TRUE, stats = c("number", "min", "max", "mean", "MAE", "RMSE"))
                 )
  }
}

knitr::kable(round(tab,2), caption = paste0("Validation croisée par K-fold (K=", n.fold,")"))

# Map of the absolute value of the validation residual
datXval <- db.add(datXval, AResidual = abs(datXval[,nm_var] - datXval[,"kfold.S.estim"]))

# The map is computed on a regular grid 1x1 km^2
dat.grd <- db.grid.init(datXval, dcell = rep(1000, 2))
dat.grd <- db.stat.grid(datXval, dat.grd, fun = "mini")
dat.grd <- db.rename(dat.grd, names = "Stats.AResidual", newnames = "Minimum of residual")
plot(dat.grd, pos.legend = 3)
```


# Estimation des coefficients

Toutes les données disponibles sont maintenant utilisées.

```{r LMOK_eval, echo=TRUE, eval=TRUE}
# Initialisation
dat = prepareDb(dat, 
                nm_fac = nm_fac,
                nm_var = nm_var, 
                nm_sel = nm_sel,
                nm_type = nm_type,
                type = type,
                sigma = resModel$sigma)
# Output file
grd <- db.grid.init(dat,nodes=c(200,200))
grd <- db.polygon(grd,dpts[[1]]$polygon )
pref<- paste(nm_var, nm_model, sep = ".")
grd <- SPDE_LMOK_krigsim(grd, dbin = dat, model = m_est, mesh = mesh,
                    nsim = 0, seed = NA, flag.ce = FALSE,
                    radix = paste("SPDE_LMOK", pref, sep = "."), verbose = TRUE)
grd <- SPDE_LMOK_krigsim(grd, dbin = dat, model = m_est, mesh = mesh,
                    nsim = nsim, seed = NA, flag.ce = TRUE,
                    radix = paste("SPDE_LMOK", pref, sep = "."), verbose = TRUE)
```


# Presentation des résultats

```{r LMOK_results, echo=TRUE, eval=TRUE}
nf <- length(db.getcols(dat, loctype = "f"))
for (i in 1:nf) {
# map of the estimated values
plot(grd, name = paste("SPDE_LMOK", pref, paste0("Z",i), "estim", sep = "."), pos.legend = 8)
# map of the standard deviation of the estimation error
plot(grd, name = paste("SPDE_LMOK", pref, paste0("Z", i), "ce.stdev", sep = "."), pos.legend = 8)
}
# statistics
tab <- db.stat.multi(grd, names = "SPDE_LMOK.*")
knitr::kable(round(tab,2), caption = "Estimation des coefficients")
```